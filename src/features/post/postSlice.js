// import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
// // import {CREATE_DATA,DELETE_DATA,NO_DATA,READ_ALL_DATA,READ_ITEM_DATA,UPDATE_DATA} from '../../app/actions/actions'

// // export const incrementAsync = createAsyncThunk(
// //   'counter/fetchCount',
// //   async (amount) => {
// //     const response = await fetchCount(amount);
// //     // The value we return becomes the `fulfilled` action payload
// //     return response.data;
// //   }
// // );

// export const initPosts = posts => {
//      console.log("data in reducer")
//      console.log(posts)
//     initialState=posts
//     return {
//         type: "READ_ALL_DATA",
//         payload: posts
//     }
// }
// var initialState =[];
// export const postSlice = createSlice({
//   name: 'poster',
//   initialState,
//   // The `reducers` field lets us define reducers and generate associated actions
//   reducers: {
//     initPosts:(state)=>{
//         state.push(this.initPosts)
//     },
//     CREATE_DATA: (state) => {
//       state.push(state.payload);
//     },
//     DELETE_DATA: (state) => {
//         const idD = state.id
//         state.reduce(idD)
//     },
//     // Use the PayloadAction type to declare the contents of `action.payload`
//     UPDATE_DATA: (state) => {
//         const id = state.id
//         const current= state.find(id)
//         current= state.payload
//     },
//     READ_ALL_DATA:(state)=>{
//         state.push(this.initPosts)
//     }

//   },
//   // The `extraReducers` field lets the slice handle actions defined elsewhere,
//   // including actions generated by createAsyncThunk or in other slices.
// //   extraReducers: (builder) => {
// //     builder
// //       .addCase(incrementAsync.pending, (state) => {
// //         state.status = 'loading';
// //       })
// //       .addCase(incrementAsync.fulfilled, (state, action) => {
// //         state.status = 'idle';
// //         state.value += action.payload;
// //       });
// //   },
//  });

// export const { CREATE_DATA, DELETE_DATA, UPDATE_DATA,READ_ALL_DATA } = postSlice.actions;

// // The function below is called a selector and allows us to select a value from
// // the state. Selectors can also be defined inline where they're used instead of
// // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// console.log("store")

// export const posts = (state) => {
//     console.log(state.poster)    
//    return state.posts.value}

// // We can also write thunks by hand, which may contain both sync and async logic.
// // Here's an example of conditionally dispatching actions based on current state.
// // export const incrementIfOdd = (amount) => (dispatch, getState) => {
// //   const currentValue = selectCount(getState());
// //   if (currentValue % 2 === 1) {
// //     dispatch(incrementByAmount(amount));
// //   }
// // };

// export default postSlice.reducer;

// // export const postReducer = (state = initialState, action) => {
// //     switch (action) {
// //         case "@post/initPosts":
// //             return action.payload
// //         case "@post/create":
// //             return state.push(state.payload)

// //         case "@post/get":
// //             return state.value
// //         case "@post/initItems":
// //             return state.value += state.data


// //         case "@post/update":
// //             const id = state.id
// //             var current = state.find(id)
// //             return current = state.payload
// //         case "@post/delete":
// //             const idD = state.id
// //             return state.reduce(idD)
// //         default:
// //             return state
// //     }

// // }
